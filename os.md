# 操作系统
## 进程、线程、协程
|进程 | 线程|
| :-- | :-- |
|资源分配的最小单位|程序执行的最小单位 |
|加载到内存中的可执行程序| |
| |一个进程内至少有一个线程（主线程）<br>例：一个程序的主线程是main，但同时还需要运行其他的（垃圾回收等）|
|各进程有独立的代码和数据空间|同一类别的线程共享代码和数据空间，每个线程都自己的栈和程序计数器|
|不同进程并发通过各自占用CPU实现|不同线程在同一个进程内可以并发，一个线程一个核|

#### 父子进程、僵尸进程、孤儿进程
- 子进程是父进程的副本，完全复制父进程的PCB(process control block,进程控制块)，代码共享，数据独立，当父进程需要执行一些可能发生阻塞或崩溃的任务时，交给子进程去做避免崩溃
- 子进程先于父进程结束，形成**僵尸进程**，由于子进程的PCB需要父进程主动回收结束信号，如果子进程结束时父进程处于休眠状态，就会形成僵尸进程，无法kill，时间久了会内存泄漏
- 父进程先于子进程结束，形成**孤儿进程**，没有危害，父进程结束时会由1号进程来接管回收子进程的PCB
- PS：0号进程是所有进程的祖先，由内核静态创建运行在内核态，1号进程是所有用户进程的祖先，由0号进程创建

#### 线程分为：
- 守护线程detached：setDaemon=True，**会在主线程结束时停止**，用于执行后台任务，主线程不用等它就可以完成自身逻辑
- 用户线程non-detached：setDaemon=False，主线程结束时，**程序会等待用户线程完成后再结束**，通常用于完成关键任务，如I/O，数据操作

- [ ] 进程间、线程间同步
- [ ] 线程之间有没有先后关系（线程依赖关系）
- [ ] 多个线程同时访问同一变量（同步互斥问题）

<font color=brown>**多线程**</font>：在一个文件中，函数根据在main中的顺序依次执行，使用多线程可以可以让每一个线程对应一个函数并发执行


## 程序在内存中的分布
![](pic/程序在内存中的分布.png s)
- 方法区是堆上的一种概念，可以被线程共享，类信息存储在方法区（包括类变量）
- 类的实例化对象存在堆中

## 面向对象：
封装、继承、多态

## 进程调度算法
1. 先来先服务 first come first serverd
    - 对于长作业友好，对短作业不友好
2. 短作业优先
    - 对短作业友好，长作业可能一直等待
3. 最短剩余时间优先
4. 时间片轮转
    - 按照FCFS原则将得到进程队列，每次调度时，队首的进程可以执行一个时间片，由于进程切换需要保存进程信息并加载新的进程，太小的时间片会导致多次进程切换浪费时间，太大的时间片不能保证实时性
5. 优先级调度
6. 多级反馈队列
    - 多个级别的队列拥有不同大小的时间片，例如1，2，4，8，在上一级别的队列中没执行完就会进入下一个队列，上面队列的优先级更高，上面没有排队的才会执行下面的

### 进程间通信
1. 管道
    - 无名管道：双向交替通信，仅用于亲缘进程通信
    - 有名管道：允许没有亲缘关系的进程通信，先进先出
2. 共享内存
3. 消息队列：存放消息的链表，在内核中
4. 套接字
5. 信号
6. 信号量：控制对于同一资源的访问的进程数量